# This benchmark counts the number of connected components in a graph represented by an adjacency matrix.
# Defines a stack interface with push and pop operations in memory
# Utilizes stack representation in memory to perfect iterative depth-first search
# Developed by Kabir Samsi (kas499)

# Returns a value between 0 and max
# Source: Code taken from adj2csr.bril
@rand(seq: ptr<int>, max: int) : int {
  a: int = const 25214903917;
  c: int = const 11;
  m: int = const 281474976710656;
  x: int = load seq;
  ax: int = mul a x;
  axpc: int = add ax c;
  next: int = div axpc m;
  next: int = mul next m;
  next: int = sub axpc next;
  store seq next;
  val: int = div next max;
  val: int = mul val max;
  val: int = sub next val;
  ret val;
}

# Push an element to the top of a stack by copying over to a larger memory component
@push(stack : ptr<int>, newnode : int, size : int) : ptr<int> {
  zero : int = const 0;

  empty : bool = eq size zero;
  br empty .push_empty .push_nonempty;

  .push_empty:
    store stack newnode;
    ret stack;

  .push_nonempty:
    one : int = const 1;
    newsize : int = add size one;
    result: ptr<int> = alloc newsize;

    # Initialize and add new node to top of the stack
    i : int = const 0;
    write_idx: ptr<int> = ptradd result i;
    store write_idx newnode;

    # Access top of the current stack
    read_idx: ptr<int> = ptradd stack i;
    
    # Set new insert position
    i : int = add i one;

    # And now just copy the rest of the array over
    .copyloop:
      cond: bool = lt i newsize;
      br cond .copy .done;
    .copy:
      # Store stack's top element at new write index
      top: int = load read_idx;
      write_idx: ptr<int> = ptradd result i;
      store write_idx top;

      # Update read index to next element
      read_idx: ptr<int> = ptradd stack i;

    .loop_end: # Increment and return to loop head
      i: int = add i one;
      jmp .copyloop;
      
    .done: # Free the old stack and return the new one
      free stack;
      ret result;
}

# Pop an element from the top of a stack
@pop(stack : ptr<int>, size : int) : ptr<int> {
  one : int = const 1;

  has_one : bool = eq size one;
  br has_one .pop_one .pop_multiple;
  
  # If the stack has only one element, store a -1 at its index
  .pop_one:
    negone : int = const -1;
    store stack negone;
    ret stack;

  .pop_multiple:
    newsize : int = sub size one;
    result: ptr<int> = alloc newsize;

    # Start copy pointer one ahead of start node, effectively popping it
    i : int = const 1;

    # Starting at index 1, copy the whole array over
    .copyloop:
      cond: bool = lt i size;
      br cond .copy .done;
    .copy:
      # Load element in
      read_idx: ptr<int> = ptradd stack i;
      top: int = load read_idx;

      # Store stack's top element at one before (overwriting the first element)
      write_pos : int = sub i one;
      write_idx: ptr<int> = ptradd result write_pos;
      store write_idx top;

    .loop_end: # Increment and return to loop head
      i: int = add i one;
      jmp .copyloop;
      
    .done: # Free the old stack and return the new one
      free stack;
      ret result;
}

# Find index of first unvisited node; return -1 if none
@first_unvisited (visited : ptr<int>, n : int) : int {
  i : int = const 0;
  zero : int = const 0;
  one : int = const 1;

  # Loop until we find an unvisited node or have gone through all elements
  .loop:
    offset = ptradd visited i;
    loaded : int = load offset;
    bounds : bool = eq i n;
    found : bool = eq offset zero;
    cond : bool = or bounds found;
    br cond .terminate .continue;
  .continue:
    i : int = add i one;
    jmp .loop;
  .terminate:
    rtn i;
}

# DFS graph to compute connected components
@dfs(graph: ptr<ptr<int>>, n : int) : int {
    
    zero : int = const 0;
    one : int = const 1;

    # Mark first node as visited
    visited : ptr<int> = alloc n;
    visited_count : int = const 0;
    components : int = const 0;

    # Iterate until every component is visited
    .component_loop:
      cond : bool = lt visited_count n;
      br cond .dfs_loop .end;

      .dfs_loop:
        # Start by finding the next unvisited element
        next_node : int = call @first_unvisited visited n;
        stack : ptr<int> = alloc one;
        stack_size : int = const 1;
        store stack next_node;
        visited_count : int = add visited_count one;

        cond : bool = gt size zero;
        br cond .trav_loop .terminate;

        .trav_loop:
          # Pop from the top of the stack
          top : int = load stack;
          stack : ptr<int> = call @pop stack stack_size;
          stack_size : int = sub stack_size one;
          
          # Add all neighbors to the top of the stack
          i : int = const 0;
          
          # Iterate through each neighbor
          .stack_loop:
            iter_cond : bool = lt i n;
            br iter_cond .iter .break;
          .iter:
            # Index and check if there is an edge.
            row_idx : int = mul top n;
            cell_idx : int = add row_idx i;
            cell : ptr<int> = ptradd graph cell_idx;
            cell_data : int = load cell;
            
            # Check if visited
            visited_cell : ptr<int> = ptradd visited i;
            visited_data : int = load visited_cell;

            is_neighbor : bool = eq cell_data one;
            not_visited : bool = eq visited_data zero;
            push_cond : bool = and is_neighbor not_visited;

            br push_cond .push_stack .no_push;

            # Mark new node as visited and add to stack
            .push_stack:
              stack : ptr<int> = call @push stack i stack_size;
              store visited_cell one;
              stack_size : int = add stack_size one;

            .no_push:
              i : int = add i one;
              jmp .stack_loop;

          .break:

        .terminate: #End single round of DFS and increment number of components
          components : int = add components one;
      
      .end:
        free stack;
        ret components;
}

# Auxiliary function to print through the contents of an array in memory
@print_through(arr : ptr<int>, size : int) {
    one: int = const 1;
    i: int = const 0;

    .loop:
        cond = lt i size;
        br cond .printmore .done;
    .printmore:
        idx: ptr<int> = ptradd arr i;
        elem: int = load idx;
        print elem;
    .loopcheck:
        i: int = add i one;
        jmp .loop;
    .done:
        print; # Line break after full print
        ret;
}

# Main block. Inputs are the number of nodes in the graph and the number of edges.
@main(nodes : int, edges: int) {
  dim : int = mul nodes nodes;
  adj : ptr<int> = alloc dim;
  one : int = const 1;

  i : int = const 0;
  .edge_loop:
    cond : bool = eq i edges;
    br cond .add_edge .end;
  .add_edge:
    i : int = add i one;
  .end:
    components : int = call @dfs adj nodes;
    free adj;
    ret components;
}